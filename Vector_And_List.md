# 벡터(Vector)   

벡터(vector)는 기본적으로 <b>동적 배열</b>이다. 즉 매번 size를 확인하며 배열이 꽉 차게되면 자동으로 capacity를 늘린다. 물론 이 과정엔 메모리를 해제했다가 다시 할당하고 값을 복사하는 오버헤드가 포함되어 있다. 또한 메모리의 잦은 할당은 <b>fragmentation</b>을 초래한다. 따라서 사용 전 <b>reserve</b>를 통해 어느정도 capacity를 정하는 것이 좋다. 배열이기 때문에 인덱스 연산을 지원하며 임의의 요소에 상수 시간으로 접근이 가능하다. 하지만 임의의 요소가 삭제되거나 추가될 때 요소의 인덱스를 유지하기 위해 백터를 재정렬 해야하는 오버헤드가 있다. 따라서 <u>맨뒤에 요소를 삽입하거나 삭제하는 연산이 아닌 중간에 삽입 삭제가 빈번하게 발생하는 경우 성능이 떨어진다.</u> 하지만 벡터는 연속된 메모리 구조를 가지는 배열이기 때문에 cpu의 cache와 잘 맞는 컨테이너이다. 

<br>

# 리스트(List)
리스트(list)는
연결 리스트(Linked list)는 독립된 노드(node)가 다음 노드를 가리키며 체인처럼 연결되어 있는 자료구조이다. 연결 리스트는 보통 배열(벡터 포함)과 달리 연속적인 메모리 구조가 아니어도 되는데, 그 이유는 각 노드 안에 데이터와 함께 다음 노드의 주소를 저장함으로써 연결을 유지하기 때문이다. 때문에 중간에 노드의 삽입 및 삭제 연산이 일어나도 관련된 노드만 연결해주면 되기 때문에 상수 시간에 연산이 가능하다. 하지만 배열과 달리 인덱스 연산을 지원하지 않아 임의의 노드에 접근하기 위해선 첫 노드부터 순차적으로 탐색해야 한다. 불연속적인 메모리 구조이기 때문에 CPU cache의 locality에 좋지 않은 조건이다. STL의 list 클래스는 양방향 연결 리스트(doubly linked list)로 구현되어 있다.
